(window.webpackJsonp=window.webpackJsonp||[]).push([[403],{806:function(_,p,v){"use strict";v.r(p);var m=v(2),t=Object(m.a)({},(function(){var _=this,p=_._self._c;return p("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[p("Boxx"),_._v(" "),p("p",[p("img",{attrs:{src:"https://www.itxbzxw.com/wp-content/uploads/2025/07/972ae83711098f0ea216ec130858c57d.jpg",alt:"C++11核心新特性与并发编程 实战课程 现代C++编程核心技能全解析（106集完结版）"}})]),_._v(" "),p("h3",{attrs:{id:"课程介绍"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#课程介绍"}},[_._v("#")]),_._v(" 课程介绍")]),_._v(" "),p("p",[_._v("课程紧贴 C++11 标准，全面讲解现代 C++ 编程的核心特性，包括字符串原始字面量、右值引用、智能指针、Lambda 表达式、constexpr、统一初始化列表、类型推导(auto、decltype)、模板增强、强枚举、友元改进、POD 类型判断等语法更新。")]),_._v(" "),p("p",[_._v("除了语言特性，还深入讲解了 **并发编程** 相关的新特性与实践，包括多线程创建、线程同步机制(mutex、condition\\_variable)、原子操作、异步任务(future、promise、async)等，帮助你掌握现代 C++ 在高并发、高性能场景下的应用技巧。")]),_._v(" "),p("p",[_._v("本课程配合大量示例代码，帮助学员快速理解、掌握并应用 C++11 新特性，适合具备一定 C++ 基础、希望进阶现代 C++ 编程能力的开发者。")]),_._v(" "),p("h3",{attrs:{id:"课程目录"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#课程目录"}},[_._v("#")]),_._v(" 课程目录")]),_._v(" "),p("p",[_._v("├─001.1.1 字符串原始字面量.mp4")]),_._v(" "),p("p",[_._v("├─002.1.2 超长整形 long long.mp4")]),_._v(" "),p("p",[_._v("├─003.1.3 类成员变量的快速初始化.mp4")]),_._v(" "),p("p",[_._v("├─004.1.4 final关键字的使用.mp4")]),_._v(" "),p("p",[_._v("├─005.1.5 overrid关键字的使用.mp4")]),_._v(" "),p("p",[_._v("├─006.1.6 对模板右尖括号的优化.mp4")]),_._v(" "),p("p",[_._v("├─007.1.7 函数模板的默认模板参数.mp4")]),_._v(" "),p("p",[_._v("├─008.1.8 静态断言 static_assert.mp4")]),_._v(" "),p("p",[_._v("├─009.1.9 异常和 noexcept.mp4")]),_._v(" "),p("p",[_._v("├─010.1.10 字符串和数值类型之间的转换.mp4")]),_._v(" "),p("p",[_._v("├─011.2.1 使用auto进行类型自动推导.mp4")]),_._v(" "),p("p",[_._v("├─012.2.2 不允许使用auto的四个场景.mp4")]),_._v(" "),p("p",[_._v("├─013.2.3 推荐使用auto的场景.mp4")]),_._v(" "),p("p",[_._v("├─014.2.4 decltype类型推导规则1.mp4")]),_._v(" "),p("p",[_._v("├─015.2.5 decltype类型推导规则2.mp4")]),_._v(" "),p("p",[_._v("├─016.2.6 decltype类型推导规则3.mp4")]),_._v(" "),p("p",[_._v("├─017.2.7 decltype在泛型编程中的使用举例.mp4")]),_._v(" "),p("p",[_._v("├─018.2.8 返回值类型后置 (追踪返回类型).mp4")]),_._v(" "),p("p",[_._v("├─019.2.9 基于范围的for循环.mp4")]),_._v(" "),p("p",[_._v("├─020.2.10 基于范围的for循环需要注意的3个细节.mp4")]),_._v(" "),p("p",[_._v("├─021.2.11 指针空值类型 nullptr.mp4")]),_._v(" "),p("p",[_._v("├─022.2.12 lambda表达式语法.mp4")]),_._v(" "),p("p",[_._v("├─023.2.13 lambda表达式的注意事项.mp4")]),_._v(" "),p("p",[_._v("├─024.2.14 lambda表达式的本质.mp4")]),_._v(" "),p("p",[_._v("├─025.3.1 constexpr 修饰常量表达式.mp4")]),_._v(" "),p("p",[_._v("├─026.3.2 常量表达式函数.mp4")]),_._v(" "),p("p",[_._v("├─027.3.3 通过using定义基础类型和函数指针别名.mp4")]),_._v(" "),p("p",[_._v("├─028.3.4 使用using和typedef给模板定义别名.mp4")]),_._v(" "),p("p",[_._v("├─029.3.5 委托构造函数.mp4")]),_._v(" "),p("p",[_._v("├─030.3.6 继承构造函数.mp4")]),_._v(" "),p("p",[_._v("├─031.3.7 统一的数据初始化方式 – 初始化列表.mp4")]),_._v(" "),p("p",[_._v("├─032.3.8 使用初始化列表初始化聚合类型的变量.mp4")]),_._v(" "),p("p",[_._v("├─033.3.9 使用初始化列表初始化非聚合类型的对象.mp4")]),_._v(" "),p("p",[_._v("├─034.3.10 initializer_list 模板类的使用.mp4")]),_._v(" "),p("p",[_._v("├─035.3.11 可调用对象.mp4")]),_._v(" "),p("p",[_._v("├─036.3.12 可调用对象包装器function的使用-1.mp4")]),_._v(" "),p("p",[_._v("├─037.3.13 可调用对象包装器function的使用-2.mp4")]),_._v(" "),p("p",[_._v("├─038.3.14 可调用对象绑定器.mp4")]),_._v(" "),p("p",[_._v("├─039.3.15 可调用对象绑定器使用-1.mp4")]),_._v(" "),p("p",[_._v("├─040.3.16 可调用对象包装器的使用-2.mp4")]),_._v(" "),p("p",[_._v("├─041.3.17 右值和右值引用.mp4")]),_._v(" "),p("p",[_._v("├─042.3.18 右值引用的作用以及使用.mp4")]),_._v(" "),p("p",[_._v("├─043.3.19 未定引用类型的推导.mp4")]),_._v(" "),p("p",[_._v("├─044.3.20 右值引用的传递.mp4")]),_._v(" "),p("p",[_._v("├─045.3.21 move资源的转移.mp4")]),_._v(" "),p("p",[_._v("├─046.3.22 forward完美转发.mp4")]),_._v(" "),p("p",[_._v("├─047.4.1 共享的智能指针-shared_ptr.mp4")]),_._v(" "),p("p",[_._v("├─048.4.2 shared_ptr共享智能指针初始化.mp4")]),_._v(" "),p("p",[_._v("├─049.4.3 共享智能指针shared_ptr的使用.mp4")]),_._v(" "),p("p",[_._v("├─050.4.4 给共享智能指针shared_ptr指定删除器.mp4")]),_._v(" "),p("p",[_._v("├─051.4.5 独占的智能指针unique_ptr的初始化和使用.mp4")]),_._v(" "),p("p",[_._v("├─052.4.6 独占的智能指针unique_ptr的删除器.mp4")]),_._v(" "),p("p",[_._v("├─053.4.7 弱引用智能指针weak_ptr的初始化和相关的操作函数.mp4")]),_._v(" "),p("p",[_._v("├─054.4.8 使用weak_ptr解决shared_ptr管理的内存被重复析构的问题.mp4")]),_._v(" "),p("p",[_._v("├─055.4.9 解决共享智能指针shared_ptr内存泄露的问题.mp4")]),_._v(" "),p("p",[_._v("├─056.5.1 POD 之平凡类型.mp4")]),_._v(" "),p("p",[_._v("├─057.5.2 POD 之标准布局类型.mp4")]),_._v(" "),p("p",[_._v("├─058.5.3 对 POD 类型的判断.mp4")]),_._v(" "),p("p",[_._v("├─059.5.4 POD 类型的优势.mp4")]),_._v(" "),p("p",[_._v("├─060.5.5 使用=default设置默认函数.mp4")]),_._v(" "),p("p",[_._v("├─061.5.6 使用=delete显示的删除函数.mp4")]),_._v(" "),p("p",[_._v("├─062.5.7 友元以及对友元的改进.mp4")]),_._v(" "),p("p",[_._v("├─063.5.8 为模板声明友元.mp4")]),_._v(" "),p("p",[_._v("├─064.5.9 强类型枚举.mp4")]),_._v(" "),p("p",[_._v("├─065.5.10 非受限联合体中静态成员的使用.mp4")]),_._v(" "),p("p",[_._v("├─066.5.11 非受限联合体中使用非POD类型的成员.mp4")]),_._v(" "),p("p",[_._v("├─067.5.12 匿名联合体作为类的成员变量.mp4")]),_._v(" "),p("p",[_._v("├─068.6.1 通过duration创建一个时间段.mp4")]),_._v(" "),p("p",[_._v("├─069.6.2 duration的算术运算.mp4")]),_._v(" "),p("p",[_._v("├─070.6.3 时间点 time_point.mp4")]),_._v(" "),p("p",[_._v("├─071.6.4 时钟类 system_clock 的使用.mp4")]),_._v(" "),p("p",[_._v("├─072.6.5 时钟类 steady_clock 的使用.mp4")]),_._v(" "),p("p",[_._v("├─073.6.6 duration_cast 函数的使用.mp4")]),_._v(" "),p("p",[_._v("├─074.6.7 time_point_cast 函数的使用.mp4")]),_._v(" "),p("p",[_._v("├─075.6.8 命名空间 this_thread.mp4")]),_._v(" "),p("p",[_._v("├─076.6.9 CPP中多线程的创建和使用-1.mp4")]),_._v(" "),p("p",[_._v("├─077.6.10 CPP中多线程的创建和使用-2.mp4")]),_._v(" "),p("p",[_._v("├─078.6.11 CPP中多线程的创建和使用-3.mp4")]),_._v(" "),p("p",[_._v("├─079.6.12 CPP中多线程的创建和使用-4.mp4")]),_._v(" "),p("p",[_._v("├─080.6.13 CPP中多线程的创建和使用-5.mp4")]),_._v(" "),p("p",[_._v("├─081.6.14 类的成员函数作为子线程的任务函数.mp4")]),_._v(" "),p("p",[_._v("├─082.6.15 call_once()函数的使用.mp4")]),_._v(" "),p("p",[_._v("├─083.6.16 call_once() 的应用 – 创建单例模式的类.mp4")]),_._v(" "),p("p",[_._v("├─084.6.17 线程同步和互斥锁.mp4")]),_._v(" "),p("p",[_._v("├─085.6.18 独占互斥锁 mutex 的使用.mp4")]),_._v(" "),p("p",[_._v("├─086.6.19 死锁和 lock_guard 类的使用.mp4")]),_._v(" "),p("p",[_._v("├─087.6.20 递归互斥锁 recursive_mutex 的使用.mp4")]),_._v(" "),p("p",[_._v("├─088.6.21 timed_mutex 和 recursive_timed_mutex 的使用.mp4")]),_._v(" "),p("p",[_._v("├─089.6.22 生产者和消费者模型.mp4")]),_._v(" "),p("p",[_._v("├─090.6.23 编写一个任务队列.mp4")]),_._v(" "),p("p",[_._v("├─091.6.24 条件变量 condition_variable 的API讲解.mp4")]),_._v(" "),p("p",[_._v("├─092.6.25 使用 condition_variable 实现生产者和消费者模型-1.mp4")]),_._v(" "),p("p",[_._v("├─093.6.26 使用 condition_variable 实现生产者和消费者模型-2.mp4")]),_._v(" "),p("p",[_._v("├─094.6.27 对生产者和消费者模型代码的优化.mp4")]),_._v(" "),p("p",[_._v("├─095.6.28 使用 condition_variable_any 实现生产者和消费者模型.mp4")]),_._v(" "),p("p",[_._v("├─096.6.29 什么是原子操作以及原子变量的特点.mp4")]),_._v(" "),p("p",[_._v("├─097.6.30 原子变量 API 详解.mp4")]),_._v(" "),p("p",[_._v("├─098.6.31 原子变量 atomic 的使用.mp4")]),_._v(" "),p("p",[_._v("├─099.6.32 使用原子变量 atomic 处理线程同步.mp4")]),_._v(" "),p("p",[_._v("├─100.6.33 原子变量中的内存顺序约束详解.mp4")]),_._v(" "),p("p",[_._v("├─101.6.34 什么是线程异步.mp4")]),_._v(" "),p("p",[_._v("├─102.6.35 future 类的功能以及使用.mp4")]),_._v(" "),p("p",[_._v("├─103.6.36 promise 类的功能和 API.mp4")]),_._v(" "),p("p",[_._v("├─104.6.37 promise 类的使用.mp4")]),_._v(" "),p("p",[_._v("├─105.6.38 packaged_task 类的使用.mp4")]),_._v(" "),p("p",[_._v("├─106.6.39 异步函数 async 的使用.mp4")]),_._v(" "),p("h2",{attrs:{id:"下载地址"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#下载地址"}},[_._v("#")]),_._v(" 下载地址：")]),_._v(" "),p("p",[p("a",{attrs:{href:"https://www.itxbzxw.com/learn/hdkf/c/11558.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("C++11核心新特性与并发编程 实战课程 现代C++编程核心技能全解析（106集完结版）-小白自学网"),p("OutboundLink")],1)])],1)}),[],!1,null,null,null);p.default=t.exports}}]);