(window.webpackJsonp=window.webpackJsonp||[]).push([[433],{837:function(v,_,a){"use strict";a.r(_);var p=a(2),i=Object(p.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("Boxx"),v._v(" "),_("p",[_("img",{attrs:{src:"https://www.itxbzxw.com/wp-content/uploads/2025/11/2db8503a0ee0d9442817eae5edd27b25.png",alt:"专项爆破JAVA多线程与高并发编程全链路实战课 原理 + 实战双驱动"}})]),v._v(" "),_("h3",{attrs:{id:"课程介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#课程介绍"}},[v._v("#")]),v._v(" 课程介绍")]),v._v(" "),_("p",[v._v("原理 + 实战双驱动：带你从底层原理到源码实现，再到企业级实战项目。")]),v._v(" "),_("p",[v._v("源码级剖析：深度拆解 `ThreadPoolExecutor`、`synchronized`、`volatile`、`LockSupport` 等核心源码。")]),v._v(" "),_("p",[v._v("高频面试题逐个爆破：结合真实企业面试题，剖析线程池、锁优化、JMM、死锁等问题。")]),v._v(" "),_("p",[v._v("可视化与调试演示：通过 JOL、jstack 等工具，动态演示线程状态与锁竞争过程。")]),v._v(" "),_("p",[v._v("实战驱动学习：手写线程池、实现生产者消费者模型、调优多线程性能。")]),v._v(" "),_("h3",{attrs:{id:"课程目录"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#课程目录"}},[v._v("#")]),v._v(" 课程目录")]),v._v(" "),_("p",[v._v("(1)\\代码;目录中文件数:1个")]),v._v(" "),_("p",[v._v("├─bjpowernode.com.zip")]),v._v(" "),_("p",[v._v("(2)\\视频;目录中文件数:1个")]),v._v(" "),_("p",[v._v("├─细说Java多线程与并发编程课程概述.mp4")]),v._v(" "),_("p",[v._v("(3)\\讲义;目录中文件数:1个")]),v._v(" "),_("p",[v._v("├─细说Java多线程与并发编程.pdf")]),v._v(" "),_("p",[v._v("(4)\\视频\\01;目录中文件数:60个")]),v._v(" "),_("p",[v._v("├─1-1 走进并发编程-计算机的基本组成(1).avi")]),v._v(" "),_("p",[v._v("├─1-1 走进并发编程-计算机的基本组成.avi")]),v._v(" "),_("p",[v._v("├─1-10 Java底层是如何创建一个线程的?.avi")]),v._v(" "),_("p",[v._v("├─1-11 线程有哪些实现方式-内核线程.avi")]),v._v(" "),_("p",[v._v("├─1-12 Linux系统能创建多少个Java线程?.avi")]),v._v(" "),_("p",[v._v("├─1-13 线程有哪些实现方式-用户线程.avi")]),v._v(" "),_("p",[v._v("├─1-14 再认识一下Java中的线程.avi")]),v._v(" "),_("p",[v._v("├─1-15 在Java中创建线程的方式继承Thread.avi")]),v._v(" "),_("p",[v._v("├─1-16 在Java中创建线程的方式实现Runnable.avi")]),v._v(" "),_("p",[v._v("├─1-17 在Java中创建线程的方式实现Callable.avi")]),v._v(" "),_("p",[v._v("├─1-18 在Java中创建线程的方式Executor.avi")]),v._v(" "),_("p",[v._v("├─1-19 在Java中创建线程的方式ThreadPoolTaskExecutor.avi")]),v._v(" "),_("p",[v._v("├─1-2 走进并发编程-认识一下CPU.avi")]),v._v(" "),_("p",[v._v("├─1-20 循序渐进去认识Java线程-一条新的执行路径.avi")]),v._v(" "),_("p",[v._v("├─1-21 循序渐进去认识Java线程-多线程执行创建几个虚拟机栈?.avi")]),v._v(" "),_("p",[v._v("├─1-22 循序渐进去认识Java线程-Java多线程程序如何Debug调试?.avi")]),v._v(" "),_("p",[v._v("├─1-23 循序渐进去认识Java线程-线程start与run方法.avi")]),v._v(" "),_("p",[v._v("├─1-24 循序渐进去认识Java线程-当前线程与休眠.avi")]),v._v(" "),_("p",[v._v("├─1-25 main线程执行结束后，在main线程中创建的子线程是否也自动结束?.avi")]),v._v(" "),_("p",[v._v("├─1-26 守护线程是怎么回事1?.avi")]),v._v(" "),_("p",[v._v("├─1-27 守护线程是怎么回事2?.avi")]),v._v(" "),_("p",[v._v("├─1-28 线程Thread API-join方法1.avi")]),v._v(" "),_("p",[v._v("├─1-29 线程Thread API-join方法2.avi")]),v._v(" "),_("p",[v._v("├─1-3 走进并发编程-摩尔定律.avi")]),v._v(" "),_("p",[v._v("├─1-30 线程Thread API-yield方法.avi")]),v._v(" "),_("p",[v._v("├─1-31 线程Thread API-getContextClassLoader.avi")]),v._v(" "),_("p",[v._v("├─1-32 线程Thread API-interrupt线程中断1.avi")]),v._v(" "),_("p",[v._v("├─1-33 线程Thread API-interrupt线程中断2.avi")]),v._v(" "),_("p",[v._v("├─1-34 线程Thread API-priority线程优先级.avi")]),v._v(" "),_("p",[v._v("├─1-35 Object wait()方法解读.avi")]),v._v(" "),_("p",[v._v("├─1-36 Object wait() notify()方法解读.avi")]),v._v(" "),_("p",[v._v("├─1-37 Object wait() interrupt()方法解读.avi")]),v._v(" "),_("p",[v._v("├─1-38 Object notifyAll()方法解读.avi")]),v._v(" "),_("p",[v._v("├─1-39 Object wait() notify() notifyAll()方法解读.avi")]),v._v(" "),_("p",[v._v("├─1-4 走进并发编程-Amdahl定律.avi")]),v._v(" "),_("p",[v._v("├─1-40 手写实现生产者-消费者模式.avi")]),v._v(" "),_("p",[v._v("├─1-41 手写实现生产者-消费者模式-代码骨架定义.avi")]),v._v(" "),_("p",[v._v("├─1-42 手写实现生产者-消费者模式-生产消费基础代码骨架.avi")]),v._v(" "),_("p",[v._v("├─1-43 手写实现生产者-消费者模式-生产消费代码实现.avi")]),v._v(" "),_("p",[v._v("├─1-44 手写实现生产者-消费者模式-生产消费代码实现.avi")]),v._v(" "),_("p",[v._v("├─1-45 手写实现生产者-消费者模式-生产消费测试.avi")]),v._v(" "),_("p",[v._v("├─1-46 线程阻塞工具类LockSupport.avi")]),v._v(" "),_("p",[v._v("├─1-47 线程阻塞工具类LockSupport-超时阻塞与唤醒.avi")]),v._v(" "),_("p",[v._v("├─1-48 线程阻塞工具类LockSupport-阻塞与唤醒的特点.avi")]),v._v(" "),_("p",[v._v("├─1-49 线程阻塞工具类LockSupport-阻塞与唤醒的特点.avi")]),v._v(" "),_("p",[v._v("├─1-5 什么是并行什么是并发?.avi")]),v._v(" "),_("p",[v._v("├─1-50 线程阻塞工具类LockSupport-阻塞与唤醒的特点.avi")]),v._v(" "),_("p",[v._v("├─1-51 Java线程的6种状态-初始状态NEW.avi")]),v._v(" "),_("p",[v._v("├─1-52 Java线程的6种状态-终止状态TERMINATED.avi")]),v._v(" "),_("p",[v._v("├─1-53 Java线程的6种状态-运行状态RUNNABLE.avi")]),v._v(" "),_("p",[v._v("├─1-54 Java线程的6种状态-等待状态WAITING.avi")]),v._v(" "),_("p",[v._v("├─1-55 Java线程的6种状态-等待状态WAITING转换到运行状态RUNNABLE.avi")]),v._v(" "),_("p",[v._v("├─1-56 Java线程的6种状态-超时等待状态TIMED_WAITING.avi")]),v._v(" "),_("p",[v._v("├─1-57 Java线程的6种状态-阻塞状态BLOCKED.avi")]),v._v(" "),_("p",[v._v("├─1-58 Java线程的6种状态-竞争Lock锁的线程状态.avi")]),v._v(" "),_("p",[v._v("├─1-59 通过jstack查看线程状态.avi")]),v._v(" "),_("p",[v._v("├─1-6 进程与线程.avi")]),v._v(" "),_("p",[v._v("├─1-7 如何查看进程下的线程及CPU占用率-Windows.avi")]),v._v(" "),_("p",[v._v("├─1-8 如何查看进程下的线程及CPU占用率-Linux.avi")]),v._v(" "),_("p",[v._v("├─1-9 如何下载JDK源码.avi")]),v._v(" "),_("p",[v._v("(5)\\视频\\02;目录中文件数:61个")]),v._v(" "),_("p",[v._v("├─2-1 什么是线程池?.avi")]),v._v(" "),_("p",[v._v("├─2-10 线程池内置的四种拒绝策略-丢弃最老和主线程执行策略.avi")]),v._v(" "),_("p",[v._v("├─2-11 线程池自定义拒绝策略.avi")]),v._v(" "),_("p",[v._v("├─2-12 线程池自定义拒绝策略应用场景案例-需求分析.avi")]),v._v(" "),_("p",[v._v("├─2-13 线程池自定义拒绝策略应用场景案例-代码实现.avi")]),v._v(" "),_("p",[v._v("├─2-14 线程池自定义拒绝策略应用场景案例-代码测试.avi")]),v._v(" "),_("p",[v._v("├─2-15 一些开源项目实现的拒绝策略.avi")]),v._v(" "),_("p",[v._v("├─2-16 线程池的核心工作原理.avi")]),v._v(" "),_("p",[v._v("├─2-17 线程池底层源码实现分析-数字的进制.avi")]),v._v(" "),_("p",[v._v("├─2-18 线程池底层源码实现分析-构造方法.avi")]),v._v(" "),_("p",[v._v("├─2-19 线程池底层源码实现分析-控制变量.avi")]),v._v(" "),_("p",[v._v("├─2-2 为什么要有线程池?.avi")]),v._v(" "),_("p",[v._v("├─2-20 线程池底层源码实现分析-线程池状态值.avi")]),v._v(" "),_("p",[v._v("├─2-21 线程池底层源码实现分析-线程池控制变量ctl.avi")]),v._v(" "),_("p",[v._v("├─2-22 线程池底层源码实现分析-解包ctl获取线程池运行状态.avi")]),v._v(" "),_("p",[v._v("├─2-23 线程池底层源码实现分析-解包ctl获取线程池工作线程个数.avi")]),v._v(" "),_("p",[v._v("├─2-24 线程池底层源码实现分析-线程池状态和工作线程数为什么用一个变量而不用两个变量?.avi")]),v._v(" "),_("p",[v._v("├─2-25 线程池底层源码实现分析-线程池状态和工作线程数控制变量?.avi")]),v._v(" "),_("p",[v._v("├─2-26 线程池底层源码实现分析-线程池底层实现核心源码分析1?.avi")]),v._v(" "),_("p",[v._v("├─2-27 线程池底层源码实现分析-线程池底层实现核心源码分析2?.avi")]),v._v(" "),_("p",[v._v("├─2-28 线程池底层源码实现分析-线程池底层实现核心源码分析3?.avi")]),v._v(" "),_("p",[v._v("├─2-29 线程池底层源码实现分析-线程池底层实现核心源码addWorker分析1?.avi")]),v._v(" "),_("p",[v._v("├─2-3 Java线程池之Executor框架.avi")]),v._v(" "),_("p",[v._v("├─2-30 线程池底层源码实现分析-线程池底层实现核心源码addWorker分析2?.avi")]),v._v(" "),_("p",[v._v("├─2-31 线程池底层源码实现分析-线程池底层实现核心源码addWorker分析3?.avi")]),v._v(" "),_("p",[v._v("├─2-32 线程池底层源码实现分析-线程池底层实现核心源码runWorker方法分析.avi")]),v._v(" "),_("p",[v._v("├─2-33 线程池底层源码实现分析-线程池底层实现核心源码getTask方法分析.avi")]),v._v(" "),_("p",[v._v("├─2-34 线程池底层源码实现分析-线程池底层实现核心源码线程复用分析.avi")]),v._v(" "),_("p",[v._v("├─2-35 线程池底层源码实现分析-线程池底层实现核心源码线程个数动态变化分析.avi")]),v._v(" "),_("p",[v._v("├─2-36 线程池底层源码实现分析-线程池底层实现核心源码流程画图总结.avi")]),v._v(" "),_("p",[v._v("├─2-37 工作中线程池的应用1.avi")]),v._v(" "),_("p",[v._v("├─2-38 工作中线程池的应用2.avi")]),v._v(" "),_("p",[v._v("├─2-39 工作中线程池的应用3.avi")]),v._v(" "),_("p",[v._v("├─2-4 Executor框架的接口与类结构.avi")]),v._v(" "),_("p",[v._v("├─2-40 工作中线程池的应用4.avi")]),v._v(" "),_("p",[v._v("├─2-41 如何合理设置线程池大小1?.avi")]),v._v(" "),_("p",[v._v("├─2-42 如何合理设置线程池大小2?.avi")]),v._v(" "),_("p",[v._v("├─2-43 如何合理设置线程池大小3?.avi")]),v._v(" "),_("p",[v._v("├─2-44 如何合理设置线程池大小4?.avi")]),v._v(" "),_("p",[v._v("├─2-45 如何合理设置线程池大小5?.avi")]),v._v(" "),_("p",[v._v("├─2-46 如何设计实现一个动态线程池?.avi")]),v._v(" "),_("p",[v._v("├─2-47 如何设计实现一个动态线程池-环境准备?.avi")]),v._v(" "),_("p",[v._v("├─2-48 如何设计实现一个动态线程池-集成配置中心?.avi")]),v._v(" "),_("p",[v._v("├─2-49 如何设计实现一个动态线程池-代码实现?.avi")]),v._v(" "),_("p",[v._v("├─2-5 线程池的7大参数解读-核心线程数.avi")]),v._v(" "),_("p",[v._v("├─2-50 如何设计实现一个动态线程池-自动刷新1?.avi")]),v._v(" "),_("p",[v._v("├─2-51 如何设计实现一个动态线程池-自动刷新2?.avi")]),v._v(" "),_("p",[v._v("├─2-52 创建线程池的方式及阿里规范.avi")]),v._v(" "),_("p",[v._v("├─2-53 线程池的扩展钩子方法.avi")]),v._v(" "),_("p",[v._v("├─2-54 线程池的监控.avi")]),v._v(" "),_("p",[v._v("├─2-55 线程池的监控-数据定时采集.avi")]),v._v(" "),_("p",[v._v("├─2-56 线程池的监控-数据定时采集代码实现1.avi")]),v._v(" "),_("p",[v._v("├─2-57 线程池的监控-数据定时采集代码实现2.avi")]),v._v(" "),_("p",[v._v("├─2-58 线程池关闭shutdownNow().avi")]),v._v(" "),_("p",[v._v("├─2-59 线程池关闭shutdown().avi")]),v._v(" "),_("p",[v._v("├─2-6 线程池的7大参数解读-任务队列与最大线程数.avi")]),v._v(" "),_("p",[v._v("├─2-60 线程池要不要关闭?.avi")]),v._v(" "),_("p",[v._v("├─2-61 线程池要不要关闭，怎么关闭?.avi")]),v._v(" "),_("p",[v._v("├─2-7 线程池的7大参数解读-空闲线程超时销毁.avi")]),v._v(" "),_("p",[v._v("├─2-8 线程池的7大参数解读-线程工厂.avi")]),v._v(" "),_("p",[v._v("├─2-9 线程池内置的四种拒绝策略-异常和丢弃策略.avi")]),v._v(" "),_("p",[v._v("(6)\\视频\\03;目录中文件数:58个")]),v._v(" "),_("p",[v._v("├─3-1 什么是线程安全?.avi")]),v._v(" "),_("p",[v._v("├─3-10 JOL查看Java对象内存布局.avi")]),v._v(" "),_("p",[v._v("├─3-11 对象头Mark Word中VALUE值解读.avi")]),v._v(" "),_("p",[v._v("├─3-12 偏向锁.avi")]),v._v(" "),_("p",[v._v("├─3-13 偏向锁加锁.avi")]),v._v(" "),_("p",[v._v("├─3-14 偏向锁释放.avi")]),v._v(" "),_("p",[v._v("├─3-15 偏向锁的设计思想.avi")]),v._v(" "),_("p",[v._v("├─3-16 轻量级锁.avi")]),v._v(" "),_("p",[v._v("├─3-17 轻量级锁加锁.avi")]),v._v(" "),_("p",[v._v("├─3-18 轻量级锁释放.avi")]),v._v(" "),_("p",[v._v("├─3-19 轻量级锁的设计思想.avi")]),v._v(" "),_("p",[v._v("├─3-2 线程安全原子性问题.avi")]),v._v(" "),_("p",[v._v("├─3-20 重量级锁.avi")]),v._v(" "),_("p",[v._v("├─3-21 重量级锁底层实现原理.avi")]),v._v(" "),_("p",[v._v("├─3-22 synchronized锁膨胀.avi")]),v._v(" "),_("p",[v._v("├─3-23 重量级锁加锁.avi")]),v._v(" "),_("p",[v._v("├─3-24 重量级锁释放.avi")]),v._v(" "),_("p",[v._v("├─3-25 用户态和内核态.avi")]),v._v(" "),_("p",[v._v("├─3-26 synchronized死锁问题.avi")]),v._v(" "),_("p",[v._v("├─3-27 死锁案例分析.avi")]),v._v(" "),_("p",[v._v("├─3-28 产生死锁的四个必要条件.avi")]),v._v(" "),_("p",[v._v("├─3-29 死锁如何解决1?.avi")]),v._v(" "),_("p",[v._v("├─3-3 线程上下文切换原子性问题.avi")]),v._v(" "),_("p",[v._v("├─3-30 死锁如何解决2?.avi")]),v._v(" "),_("p",[v._v("├─3-31 死锁如何解决3?.avi")]),v._v(" "),_("p",[v._v("├─3-32 synchronized与脏读问题.avi")]),v._v(" "),_("p",[v._v("├─3-33 内存不可见问题.avi")]),v._v(" "),_("p",[v._v("├─3-34 聊聊CPU三级高速缓存.avi")]),v._v(" "),_("p",[v._v("├─3-35 Java内存模型.avi")]),v._v(" "),_("p",[v._v("├─3-36 volatile关键字的应用.avi")]),v._v(" "),_("p",[v._v("├─3-37 volatile可见性与原子性.avi")]),v._v(" "),_("p",[v._v("├─3-38 volatile与有序性.avi")]),v._v(" "),_("p",[v._v("├─3-39 volatile的使用场景.avi")]),v._v(" "),_("p",[v._v("├─3-4 指令原子性问题的分析.avi")]),v._v(" "),_("p",[v._v("├─3-40 多线程单例模式-饿汉式设计.avi")]),v._v(" "),_("p",[v._v("├─3-41 多线程单例模式-懒汉式设计.avi")]),v._v(" "),_("p",[v._v("├─3-42 多线程单例模式-懒汉式安全设计.avi")]),v._v(" "),_("p",[v._v("├─3-43 多线程单例模式-DCL设计.avi")]),v._v(" "),_("p",[v._v("├─3-44 多线程单例模式-DCL重排序设计.avi")]),v._v(" "),_("p",[v._v("├─3-45 多线程单例模式-静态代码块设计.avi")]),v._v(" "),_("p",[v._v("├─3-46 多线程单例模式-静态内部类设计.avi")]),v._v(" "),_("p",[v._v("├─3-47 多线程单例模式-枚举类设计.mp4")]),v._v(" "),_("p",[v._v("├─3-48 饿汉式单例防反射攻击.mp4")]),v._v(" "),_("p",[v._v("├─3-49 饿汉式单例防反序列化攻击.mp4")]),v._v(" "),_("p",[v._v("├─3-5 synchronized解决线程安全.avi")]),v._v(" "),_("p",[v._v("├─3-50 懒汉式单例反射攻击.mp4")]),v._v(" "),_("p",[v._v("├─3-51 懒汉式单例反序列化攻击.mp4")]),v._v(" "),_("p",[v._v("├─3-52 懒汉式单例的攻击问题.mp4")]),v._v(" "),_("p",[v._v("├─3-53 静态代码块反射与序列化攻击.mp4")]),v._v(" "),_("p",[v._v("├─3-54 静态内部类反射与序列化攻击.mp4")]),v._v(" "),_("p",[v._v("├─3-55 枚举类单例反射攻击剖析.mp4")]),v._v(" "),_("p",[v._v("├─3-56 枚举类单例序列化攻击剖析.mp4")]),v._v(" "),_("p",[v._v("├─3-57 单例设计模式性能比较.mp4")]),v._v(" "),_("p",[v._v("├─3-58 开源项目中的单例设计模式.mp4")]),v._v(" "),_("p",[v._v("├─3-6 synchronized对象锁.avi")]),v._v(" "),_("p",[v._v("├─3-7 synchronized类锁.avi")]),v._v(" "),_("p",[v._v("├─3-8 Java对象头Mark Word结构分析.avi")]),v._v(" "),_("p",[v._v("├─3-9 Java对象内存布局.avi")]),v._v(" "),_("p",[v._v("(7)\\视频\\04;目录中文件数:5个")]),v._v(" "),_("p",[v._v("├─4-1 Runnable接口.avi")]),v._v(" "),_("p",[v._v("├─4-2 Callable接口.avi")]),v._v(" "),_("p",[v._v("├─4-3 Future接口.avi")]),v._v(" "),_("p",[v._v("├─4-4 FutureTask类1.avi")]),v._v(" "),_("p",[v._v("├─4-5 FutureTask类2.avi")]),v._v(" "),_("p",[v._v("(8)\\视频\\05;目录中文件数:16个")]),v._v(" "),_("p",[v._v("├─5-1 ThreadLocal是什么?.avi")]),v._v(" "),_("p",[v._v("├─5-10 HashMap链表节点过深时为什么选择使用红黑树2?.avi")]),v._v(" "),_("p",[v._v("├─5-11 HashMap链表节点过深时为什么选择使用红黑树3?.avi")]),v._v(" "),_("p",[v._v("├─5-12 什么是hash碰撞，发生hash碰撞怎么办?.avi")]),v._v(" "),_("p",[v._v("├─5-13 ConcurrentHashMap的底层实现原理1?.avi")]),v._v(" "),_("p",[v._v("├─5-14 ConcurrentHashMap的底层实现原理2?.avi")]),v._v(" "),_("p",[v._v("├─5-15 ThreadLocal的实现原理?.avi")]),v._v(" "),_("p",[v._v("├─5-16 ThreadLocal为什么会发生内存泄漏?.avi")]),v._v(" "),_("p",[v._v("├─5-2 ThreadLocal应用.avi")]),v._v(" "),_("p",[v._v("├─5-3 说说你对HashMap的理解和认识?.avi")]),v._v(" "),_("p",[v._v("├─5-4 HashMap有哪些主要特征和注意事项?.avi")]),v._v(" "),_("p",[v._v("├─5-5 说说HashMap的底层数据存储结构?.avi")]),v._v(" "),_("p",[v._v("├─5-6 HashMap多线程条件下死循环是怎么回事?.avi")]),v._v(" "),_("p",[v._v("├─5-7 多线程条件下HashMap数据丢失问题?.avi")]),v._v(" "),_("p",[v._v("├─5-8 多线程条件下HashMap都存在什么问题?.avi")]),v._v(" "),_("p",[v._v("├─5-9 HashMap链表节点过深时为什么选择使用红黑树1?.avi")]),v._v(" "),_("h2",{attrs:{id:"下载地址"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#下载地址"}},[v._v("#")]),v._v(" 下载地址：")]),v._v(" "),_("p",[_("a",{attrs:{href:"https://www.itxbzxw.com/learn/hdkf/java/11868.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("专项爆破JAVA多线程与高并发编程全链路实战课 原理 + 实战双驱动-小白自学网"),_("OutboundLink")],1)])],1)}),[],!1,null,null,null);_.default=i.exports}}]);