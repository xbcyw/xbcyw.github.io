(window.webpackJsonp=window.webpackJsonp||[]).push([[328],{737:function(_,p,v){"use strict";v.r(p);var t=v(2),a=Object(t.a)({},(function(){var _=this,p=_._self._c;return p("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[p("Boxx"),_._v(" "),p("p",[p("img",{attrs:{src:"https://www.itxbzxw.com/wp-content/uploads/2025/01/0964e3228c356dd9602fdbdd70d25f29.jpg",alt:"系统化学习C++多线程编程 从基础概念到高级应用 打造高效可靠的多线程系统"}})]),_._v(" "),p("h3",{attrs:{id:"课程介绍"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#课程介绍"}},[_._v("#")]),_._v(" 课程介绍:")]),_._v(" "),p("p",[_._v("在这个课程中，我们将从C++多线程的基本概念开始，逐步深入探讨多线程编程的原理和技术细节。通过大量实例演示和代码实践，您将学会如何创建、管理和同步多个线程，以及如何处理线程间的通信和共享资源的问题。")]),_._v(" "),p("p",[_._v("除此之外，我们还将重点介绍线程池的概念、设计原理和实现方法，并通过实战项目，帮助您掌握线程池的应用技巧和调优策略，提高多线程编程的效率和稳定性。")]),_._v(" "),p("p",[_._v("通过本课程的学习，您将成为C++多线程编程的专家，具备深入理解多线程原理和灵活应用线程池的能力。")]),_._v(" "),p("h3",{attrs:{id:"课程目录"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#课程目录"}},[_._v("#")]),_._v(" 课程目录:")]),_._v(" "),p("p",[_._v("├─1-1 课程介绍.mp4")]),_._v(" "),p("p",[_._v("├─1-2 为什么要使用多线程_第一个线程代码示例.mp4")]),_._v(" "),p("p",[_._v("├─1-3 thread 对象生命周期和线程等待和分离.mp4")]),_._v(" "),p("p",[_._v("├─1-4 全局函数作为线程入口分析参数传递内存操作.mp4")]),_._v(" "),p("p",[_._v("├─1-5 线程函数传递指针和引用.mp4")]),_._v(" "),p("p",[_._v("├─1-6 使用成员函数作为线程入口并封装线程基类接口.mp4")]),_._v(" "),p("p",[_._v("├─1-7 lambda临时函数作为线程入口.mp4")]),_._v(" "),p("p",[_._v("├─2-1 多线程的状态及其切换流程分析.mp4")]),_._v(" "),p("p",[_._v("├─2-2 竞争状态和临界区介绍_互斥锁mutex代码演示.mp4")]),_._v(" "),p("p",[_._v("├─2-3 互斥锁的坑_线程抢占不到资源原因和解决方法.mp4")]),_._v(" "),p("p",[_._v("├─2-4 超时锁timed_mutex和可重入锁recursive.mp4")]),_._v(" "),p("p",[_._v("├─2-5 共享锁shared_mutex解决读写问题.mp4")]),_._v(" "),p("p",[_._v("├─3-1 手动实现RAII管理mutex资源_锁自动释放.mp4")]),_._v(" "),p("p",[_._v("├─3-2 c++11RAII控制锁lock_guard.mp4")]),_._v(" "),p("p",[_._v("├─3-3 unique_lock可临时解锁控制超时的互斥体包装器.mp4")]),_._v(" "),p("p",[_._v("├─3-4 C++14shared_lock共享锁包装器.mp4")]),_._v(" "),p("p",[_._v("├─3-5 c++17scoped_lock解决互锁造成的死锁问题.mp4")]),_._v(" "),p("p",[_._v("├─3-6 项目案例线程通信使用互斥锁和list实现线程通信.mp4")]),_._v(" "),p("p",[_._v("├─3-7 条件变量应用场景_生产者消费者信号处理步骤.mp4")]),_._v(" "),p("p",[_._v("├─3-8 condition_variable代码示例读写线程同步.mp4")]),_._v(" "),p("p",[_._v("├─3-9 条件变量应用线程通信解决线程退出时的阻塞问题.mp4")]),_._v(" "),p("p",[_._v("├─4-1 promise和future多线程异步传值.mp4")]),_._v(" "),p("p",[_._v("├─4-2 packaged_task 异步调用函数打包.mp4")]),_._v(" "),p("p",[_._v("├─4-3 async创建异步线程替代thread.mp4")]),_._v(" "),p("p",[_._v("├─4-4 c++多核计算分析并实现base16编码.mp4")]),_._v(" "),p("p",[_._v("├─4-5 c++11实现多核base16编码并与单核性能测试对比.mp4")]),_._v(" "),p("p",[_._v("├─4-6 c++17for_each多核运算示例编码base16.mp4")]),_._v(" "),p("p",[_._v("├─4-7 线程池实现步骤说明.mp4")]),_._v(" "),p("p",[_._v("├─5-1 完成线程池的初始化和启动.mp4")]),_._v(" "),p("p",[_._v("├─5-2 完成线程池任务调度.mp4")]),_._v(" "),p("p",[_._v("├─5-3 完成线程池退出并等待任务处理结束利用lambada表达式.mp4")]),_._v(" "),p("p",[_._v("├─5-4 线程池中在在运行的任务数量获取使用atomic原子变量.mp4")]),_._v(" "),p("p",[_._v("├─5-5 使用智能指针管理线程对象和任务对象的生命走起.mp4")]),_._v(" "),p("p",[_._v("├─5-6 异步获取线程池中任务执行结果.mp4")]),_._v(" "),p("p",[_._v("├─5-7 基于线程池实现音视频批量转码测试任务.mp4")]),_._v(" "),p("p",[_._v("├─5-8 完成线程池案例基于ffmpeg工具多线程转码视频.mp4")]),_._v(" "),p("p",[_._v("├─6-1 c++20屏障barrier实现线程协调.mp4")]),_._v(" "),p("p",[_._v("├─6-2 课程总结.mp4")]),_._v(" "),p("p",[_._v("├─资料.zip")]),_._v(" "),p("h2",{attrs:{id:"下载地址"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#下载地址"}},[_._v("#")]),_._v(" 下载地址：")]),_._v(" "),p("p",[p("a",{attrs:{href:"https://www.itxbzxw.com/learn/hdkf/c/10387.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("系统化学习C++多线程编程 从基础概念到高级应用 打造高效可靠的多线程系统-小白自学网"),p("OutboundLink")],1)])],1)}),[],!1,null,null,null);p.default=a.exports}}]);