(window.webpackJsonp=window.webpackJsonp||[]).push([[439],{844:function(v,p,_){"use strict";_.r(p);var M=_(2),e=Object(M.a)({},(function(){var v=this,p=v._self._c;return p("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[p("Boxx"),v._v(" "),p("p",[p("img",{attrs:{src:"https://www.itxbzxw.com/wp-content/uploads/2025/11/e49c8e6c8df527d923479e03bdb548f9.png",alt:"Java并发编程进阶技术实践百度网盘下载"}})]),v._v(" "),p("h3",{attrs:{id:"课程目录"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#课程目录"}},[v._v("#")]),v._v(" 课程目录：")]),v._v(" "),p("p",[v._v("├──01 第一章 同步器AQS")]),v._v(" "),p("p",[v._v("| ├──01 AQS的概念和原理")]),v._v(" "),p("p",[v._v("| | ├──05 1-1-4AQS源码解析之同步状态的原子性管理.mp4 8.14M")]),v._v(" "),p("p",[v._v("| | ├──06 1-1-5AQS源码解析之acquire方法源码简介.mp4 16.37M")]),v._v(" "),p("p",[v._v("| | ├──07 1-1-6AQS源码解析之release方法源码简介.mp4 11.32M")]),v._v(" "),p("p",[v._v("| | ├──08 1-1-7AQS源码解析之acquireShared和releaseShared方法简介.mp4 15.15M")]),v._v(" "),p("p",[v._v("| | ├──09 1-1-8AQS源码解析之acqureiInterruptibly和tryAcquireNanos方法简介.mp4 15.67M")]),v._v(" "),p("p",[v._v("| | ├──01 1-0-1课程介绍和学习目标.mp4 7.84M")]),v._v(" "),p("p",[v._v("| | ├──02 1-1-1AQS的概念和工作模式.mp4 9.57M")]),v._v(" "),p("p",[v._v("| | ├──03 1-1-2回顾对象锁的工作原理.mp4 15.22M")]),v._v(" "),p("p",[v._v("| | └──04 1-1-3AQS的核心组件及工作流程.mp4 7.64M")]),v._v(" "),p("p",[v._v("| └──02 AQS的数据结构及使用方式、Lock框架的再认识")]),v._v(" "),p("p",[v._v("| | ├──01 1-2-1AQS队列数据结构的基本介绍.mp4 5.67M")]),v._v(" "),p("p",[v._v("| | ├──02 1-2-2Node内部类源码解析.mp4 10.15M")]),v._v(" "),p("p",[v._v("| | ├──03 1-2-3同步队列节点的入队操作.mp4 32.27M")]),v._v(" "),p("p",[v._v("| | ├──06 1-2-6等待队列节点的出队操作.mp4 20.85M")]),v._v(" "),p("p",[v._v("| | ├──07 1-2-7共享模式下节点的入队与出队操作.mp4 27.34M")]),v._v(" "),p("p",[v._v("| | ├──08 1-2-8关于节点的取消状态.mp4 54.28M")]),v._v(" "),p("p",[v._v("| | ├──09 1-3-1AQS的设计模式之模板方法.mp4 33.39M")]),v._v(" "),p("p",[v._v("| | ├──10 1-3-2自定义一个简单的互斥锁.mp4 45.98M")]),v._v(" "),p("p",[v._v("| | ├──11 1-3-3自定义一个可重入的互斥锁.mp4 37.08M")]),v._v(" "),p("p",[v._v("| | ├──12 1-3-4共享锁的实现思路及注意事项.mp4 23.87M")]),v._v(" "),p("p",[v._v("| | ├──13 1-4-1Lock和synchronized的区别.mp4 26.18M")]),v._v(" "),p("p",[v._v("| | ├──14 1-4-2公平与非公平的底层支持：可闯入策略.mp4 34.28M")]),v._v(" "),p("p",[v._v("| | ├──16 1-4-4读写锁ReentrantReadWriteLock的基本使用.mp4 18.02M")]),v._v(" "),p("p",[v._v("| | ├──17 1-4-5读写锁的适用性与关注点.mp4 18.22M")]),v._v(" "),p("p",[v._v("| | ├──18 1-4-6Callable、Future和FutureTask回顾.mp4 24.73M")]),v._v(" "),p("p",[v._v("| | ├──19 1-4-7ForkJoin框架与工作秘取的基本概念.mp4 7.55M")]),v._v(" "),p("p",[v._v("| | ├──20 1-4-8ForkJoinTask与两个常用子类RecursiveTask、RecursiveAction源码概述.mp4 31.04M")]),v._v(" "),p("p",[v._v("| | ├──21 1-4-9ForkJoin案例：分别使用单线程和fork-join框架运算数组元素之和.mp4 60.17M")]),v._v(" "),p("p",[v._v("| | ├──22 1-4-10ForkJoin案例：使用RecursiveAction遍历目录(含子目录)打印指定类型文件.mp4 30.69M")]),v._v(" "),p("p",[v._v("| | ├──04 1-2-4同步队列节点的出队操作.mp4 21.11M")]),v._v(" "),p("p",[v._v("| | ├──05 1-2-5等待队列节点的入队操作.mp4 23.97M")]),v._v(" "),p("p",[v._v("| | └──15 1-4-3使用synchronized关键字实现读多写少的测试.mp4 30.75M")]),v._v(" "),p("p",[v._v("├──02 第二章 并发容器")]),v._v(" "),p("p",[v._v("| ├──00 资料")]),v._v(" "),p("p",[v._v("| | └──Java并发编程高阶技术实践")]),v._v(" "),p("p",[v._v("| └──01 并发容器-课程所有资料在本节下载")]),v._v(" "),p("p",[v._v("| | ├──01 2-0-1课程介绍与学习目标.mp4 4.47M")]),v._v(" "),p("p",[v._v("| | ├──02 2-1-1ConcurrentHashMap预备知识：hash算法和位运算.mp4 12.56M")]),v._v(" "),p("p",[v._v("| | ├──03 2-1-2ConcurrentHashMap数据结构预览.mp4 11.96M")]),v._v(" "),p("p",[v._v("| | ├──04 2-1-3ConcurrentHashMap在jdk1.7及以前的实现原理概述.mp4 7.88M")]),v._v(" "),p("p",[v._v("| | ├──05 2-1-4ConcurrentHashMap在jdk1.7及以前的初始化源码解析.mp4 30.25M")]),v._v(" "),p("p",[v._v("| | ├──06 2-1-5ConcurrentHashMap在jdk1.7及以前的get()方法源码解析.mp4 35.80M")]),v._v(" "),p("p",[v._v("| | ├──07 2-1-6ConcurrentHashMap在jdk1.7及以前的put()方法源码解析.mp4 40.30M")]),v._v(" "),p("p",[v._v("| | ├──08 2-1-7ConcurrentHashMap在jdk1.7及以前的扩容机制和size()方法源码解析.mp4 33.44M")]),v._v(" "),p("p",[v._v("| | ├──09 2-1-8ConcurrentHashMap在jdk8及以后的实现原理概述.mp4 14.75M")]),v._v(" "),p("p",[v._v("| | ├──10 2-1-9ConcurrentHashMap在jdk8及以后的初始化和put()方法源码解析.mp4 63.95M")]),v._v(" "),p("p",[v._v("| | ├──11 2-1-10ConcurrentHashMap在jdk8及以后的get()方法源码解析.mp4 13.32M")]),v._v(" "),p("p",[v._v("| | ├──12 2-1-11ConcurrentHashMap在jdk8及以后的扩容机制和size()方法源码解析.mp4 42.42M")]),v._v(" "),p("p",[v._v("| | ├──13 2-1-12ConcurrentHashMap在jdk8及以后的总结.mp4 26.94M")]),v._v(" "),p("p",[v._v("| | ├──14 2-2-1跳表SkipList的工作原理.mp4 10.96M")]),v._v(" "),p("p",[v._v("| | ├──15 2-2-2无界非阻塞队列ConcurrentLinkedQueue简介.mp4 6.66M")]),v._v(" "),p("p",[v._v("| | ├──16 2-2-3写时复制容器简介.mp4 5.22M")]),v._v(" "),p("p",[v._v("| | ├──17 2-3-1阻塞队列的概念及由来.mp4 6.18M")]),v._v(" "),p("p",[v._v("| | ├──18 2-3-2阻塞队列的常用方法辨析.mp4 43.16M")]),v._v(" "),p("p",[v._v("| | ├──19 2-3-3常见阻塞队列及各自特点辨析.mp4 72.36M")]),v._v(" "),p("p",[v._v("| | ├──20 2-3-4使用DelayQueue实现延时订单-延时队列元素工具类定义.mp4 43.43M")]),v._v(" "),p("p",[v._v("| | ├──21 2-3-5使用DelayQueue实现延时订单-生产者和消费者线程定义及测试.mp4 44.92M")]),v._v(" "),p("p",[v._v("| | └──22 2-3-6阻塞队列的底层实现：显示锁+等待通知机制.mp4 13.66M")]),v._v(" "),p("p",[v._v("├──03 第三章 线程池")]),v._v(" "),p("p",[v._v("| └──01 线程池")]),v._v(" "),p("p",[v._v("| | ├──01 3-0-1课程介绍与学习目标.mp4 6.18M")]),v._v(" "),p("p",[v._v("| | ├──02 3-1-1线程池的概念和好处.mp4 13.93M")]),v._v(" "),p("p",[v._v("| | ├──03 3-1-2自定义线程池：思路分析.mp4 15.05M")]),v._v(" "),p("p",[v._v("| | ├──04 3-1-3自定义线程池：创建线程池，初始化工作线程.mp4 30.45M")]),v._v(" "),p("p",[v._v("| | ├──05 3-1-4自定义线程池：工作线程从任务队列中获取任务并执行.mp4 26.83M")]),v._v(" "),p("p",[v._v("| | ├──06 3-1-5自定义线程池：提供execute方法供调用者执行任务.mp4 13.84M")]),v._v(" "),p("p",[v._v("| | ├──07 3-1-6自定义线程池：提供destroy方法用于销毁线程池.mp4 23.18M")]),v._v(" "),p("p",[v._v("| | ├──08 3-1-7自定义线程池：测试及线程池工作流程.mp4 50.06M")]),v._v(" "),p("p",[v._v("| | ├──09 3-2-1ThreadPoolExecutor源码分析：初始化线程池参数.mp4 71.45M")]),v._v(" "),p("p",[v._v("| | ├──10 3-2-2ThreadPoolExecutor源码分析：提交任务execute和submit方法.mp4 35.14M")]),v._v(" "),p("p",[v._v("| | ├──11 3-2-3ThreadPoolExecutor源码分析：关闭线程池shutdown和shutdowNow方法.mp4 7.27M")]),v._v(" "),p("p",[v._v("| | ├──12 3-2-4线程池工作机制.mp4 6.75M")]),v._v(" "),p("p",[v._v("| | ├──13 3-2-5使用ThreadPoolExecutor创建线程池并使用.mp4 33.10M")]),v._v(" "),p("p",[v._v("| | ├──14 3-2-6提交带返回值的任务到ThreadPoolExecutor线程池.mp4 28.20M")]),v._v(" "),p("p",[v._v("| | ├──15 3-2-7线程池的关闭：shutdown与shutdownNow方法的使用.mp4 28.07M")]),v._v(" "),p("p",[v._v("| | ├──16 3-2-8合理配置线程池.mp4 18.06M")]),v._v(" "),p("p",[v._v("| | ├──17 3-3-1系统预定义线程池简介.mp4 22.43M")]),v._v(" "),p("p",[v._v("| | ├──18 3-3-2定时任务ScheduledThreadPoolExecutor用法.mp4 61.43M")]),v._v(" "),p("p",[v._v("| | ├──19 3-3-3定时任务ScheduledThreadPoolExecutor异常处理.mp4 24.77M")]),v._v(" "),p("p",[v._v("| | ├──20 3-3-4Executor框架继承体系和使用流程.mp4 27.28M")]),v._v(" "),p("p",[v._v("| | ├──21 3-3-5CompletionService按线程池中任务完成顺序获取结果.mp4 40.14M")]),v._v(" "),p("p",[v._v("| | └──22 3-3-6CompletionService实现原理.mp4 18.50M")]),v._v(" "),p("p",[v._v("├──04 第四章 并发安全")]),v._v(" "),p("p",[v._v("| └──01 并发安全")]),v._v(" "),p("p",[v._v("| | ├──01 4-0-1并发安全：课程简介和学习目标.mp4 7.64M")]),v._v(" "),p("p",[v._v("| | ├──02 4-1-1什么是类的线程安全.mp4 7.47M")]),v._v(" "),p("p",[v._v("| | ├──03 4-1-2类的线程安全：无状态、加锁和CAS操作.mp4 11.20M")]),v._v(" "),p("p",[v._v("| | ├──04 4-1-3类的线程安全：让类不可变 – 属性加final.mp4 24.86M")]),v._v(" "),p("p",[v._v("| | ├──05 4-1-4类的线程安全：让类不可变 – 不提供修改属性的方式.mp4 19.30M")]),v._v(" "),p("p",[v._v("| | ├──06 4-1-5类的线程安全：栈封闭.mp4 26.93M")]),v._v(" "),p("p",[v._v("| | ├──07 4-1-6类的线程安全：volatile、安全的发布、ThreadLocal.mp4 17.69M")]),v._v(" "),p("p",[v._v("| | ├──08 4-2-1死锁产生的原因.mp4 4.71M")]),v._v(" "),p("p",[v._v("| | ├──09 4-2-2常见的死锁发生的两个场景.mp4 26.41M")]),v._v(" "),p("p",[v._v("| | ├──10 4-2-3动态顺序死锁的产生.mp4 17.28M")]),v._v(" "),p("p",[v._v("| | ├──11 4-2-4动态顺序死锁的解决方案一：内在排序.mp4 46.14M")]),v._v(" "),p("p",[v._v("| | ├──12 4-2-5动态顺序死锁的解决方案二：Lock.tryLock方法.mp4 35.81M")]),v._v(" "),p("p",[v._v("| | ├──13 4-2-6活锁与饥饿.mp4 25.22M")]),v._v(" "),p("p",[v._v("| | ├──14 4-3-1衡量多线程引用性能的指标与影响因素.mp4 16.12M")]),v._v(" "),p("p",[v._v("| | ├──15 4-3-2锁优化：缩小锁的范围.mp4 32.32M")]),v._v(" "),p("p",[v._v("| | ├──16 4-3-3锁优化：减少锁的粒度.mp4 20.92M")]),v._v(" "),p("p",[v._v("| | ├──17 4-3-4锁优化：锁分段和替换独占锁.mp4 7.93M")]),v._v(" "),p("p",[v._v("| | ├──18 4-3-5常见的两种单例设计模式.mp4 13.40M")]),v._v(" "),p("p",[v._v("| | ├──19 4-3-6使用枚举实现单例：防止反射攻击.mp4 8.95M")]),v._v(" "),p("p",[v._v("| | ├──20 4-3-7懒汉式单例模式：双重检查确保并发安全.mp4 13.20M")]),v._v(" "),p("p",[v._v("| | ├──21 4-3-8懒汉式单例模式：双重检查的问题及解决方案.mp4 15.63M")]),v._v(" "),p("p",[v._v("| | └──22 4-3-9单例设计模式大杀器：延迟占位模式.mp4 24.65M")]),v._v(" "),p("p",[v._v("└──05 第五章 Java内存模型")]),v._v(" "),p("p",[v._v("| └──01 Java内存模型")]),v._v(" "),p("p",[v._v("| | ├──01 5-0-1课程介绍与学习目标.mp4 6.50M")]),v._v(" "),p("p",[v._v("| | ├──02 5-1-1现代计算机物理内存模型.mp4 15.58M")]),v._v(" "),p("p",[v._v("| | ├──03 5-1-2物理内存模型带来的问题.mp4 16.37M")]),v._v(" "),p("p",[v._v("| | ├──04 5-2-1并发编程模型的分类.mp4 10.55M")]),v._v(" "),p("p",[v._v("| | ├──05 5-2-3Java内存模型图示.mp4 11.45M")]),v._v(" "),p("p",[v._v("| | ├──06 5-2-4Java线程通信的实现.mp4 4.50M")]),v._v(" "),p("p",[v._v("| | ├──07 5-2-5Java虚拟机的体系结构.mp4 12.49M")]),v._v(" "),p("p",[v._v("| | ├──08 5-2-6JMM在JVM中的实现：栈【1】.mp4 10.05M")]),v._v(" "),p("p",[v._v("| | ├──09 5-2-7JMM在JVM中的实现：堆.mp4 4.91M")]),v._v(" "),p("p",[v._v("| | ├──10 5-2-8JMM在JVM中的实现：方法区.mp4 15.88M")]),v._v(" "),p("p",[v._v("| | ├──11 5-2-9堆栈溢出异常：StackOverFlowError和OutOfMemoryError.mp4 19.89M")]),v._v(" "),p("p",[v._v("| | ├──12 5-2-10基于共享内存的JMM的问题：可见性和竞争.mp4 5.89M")]),v._v(" "),p("p",[v._v("| | ├──13 5-2-11重排序的概念和分类.mp4 12.77M")]),v._v(" "),p("p",[v._v("| | ├──14 5-2-12重排序与依赖性：数据依赖性.mp4 16.45M")]),v._v(" "),p("p",[v._v("| | ├──15 5-2-13重排序与依赖性：控制依赖性与as-if-serieal语义.mp4 14.58M")]),v._v(" "),p("p",[v._v("| | ├──16 5-2-14并发下重排序的问题.mp4 18.05M")]),v._v(" "),p("p",[v._v("| | ├──17 5-2-15并发下重排序问题的解决方案：临界区.mp4 8.34M")]),v._v(" "),p("p",[v._v("| | ├──18 5-2-16并发下重排序问题的解决方案：内存屏障.mp4 15.09M")]),v._v(" "),p("p",[v._v("| | ├──19 5-3-1Happens-Before规则的概念.mp4 7.62M")]),v._v(" "),p("p",[v._v("| | ├──20 5-3-2无须任何同步手段就可以保证的Happens-Before规则.mp4 13.66M")]),v._v(" "),p("p",[v._v("| | ├──21 5-3-3final关键字的内存语义.mp4 12.00M")]),v._v(" "),p("p",[v._v("| | ├──22 5-3-4volatile关键字的内存语义.mp4 4.34M")]),v._v(" "),p("p",[v._v("| | ├──23 5-3-5volatile关键字内存语义的实现.mp4 10.27M")]),v._v(" "),p("p",[v._v("| | ├──24 5-4-1锁的内存语义.mp4 4.18M")]),v._v(" "),p("p",[v._v("| | └──25 5-4-2synchronized的实现原理.mp4 6.62M")]),v._v(" "),p("h2",{attrs:{id:"下载地址"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#下载地址"}},[v._v("#")]),v._v(" 下载地址：")]),v._v(" "),p("p",[p("a",{attrs:{href:"https://www.itxbzxw.com/learn/hdkf/java/11918.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("Java并发编程进阶技术实践百度网盘下载-小白自学网"),p("OutboundLink")],1)])],1)}),[],!1,null,null,null);p.default=e.exports}}]);